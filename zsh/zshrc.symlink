
#-------------------------------------------------------------------------------
# Initialization
#-------------------------------------------------------------------------------

# Cached Files
# ============
zsh_cache=${HOME}/.zsh_cache
mkdir -p $zsh_cache

# Auto-Completion
# ===============
autoload -U compinit

if [ $UID -eq 0 ]; then
    # we don't want root screwing with the permissions in the $zsh_cache
    # directory.
    compinit
else
    compinit -d $zsh_cache/zcomp-$HOST
fi

# Recompile
# =========
autoload -U zrecompile

if [ $UID -ne 0 ]; then
    for file in ~/.zshrc $zsh_cache/zcomp-$HOST; do
        zrecompile -p $file && rm -f $file.zwc.old
    done
fi

#-------------------------------------------------------------------------------
# Aliases
#-------------------------------------------------------------------------------
alias ls='ls --color=auto'
alias ll='ls -l'
alias llt='ls -lt'
alias lla='ls -lA'
alias lss='ls -sh'
alias grep='grep --color=auto'

#-------------------------------------------------------------------------------
# History
#-------------------------------------------------------------------------------

HISTSIZE=1000
SAVEHIST=1000
HISTFILE=~/.zsh_history

setopt SHARE_HISTORY        # Share history across sessions
setopt HIST_IGNORE_SPACE    # commands starting w/ a space don't go into history

# SHARE_HISTORY seems to imply both of these, at least that's how the manpage
#   reads, so let's comment them out for now.
#
# setopt INC_APPEND_HISTORY   # Incrementally append history to file
# setopt EXTENDED_HISTORY     # Save the timestamp and duration of commands to history file

#-------------------------------------------------------------------------------
# Auto Functions
#-------------------------------------------------------------------------------
source "$DOTFILES_DIR/zsh/lib/auto-functions.zsh"


#-------------------------------------------------------------------------------
# Miscellaneous
#-------------------------------------------------------------------------------

setopt NOBEEP       # No more beeps! Huzzah! \o/
setopt NO_NOMATCH   # Don't die when a glob expansion matches no files

# LS_COLORS
# =========
if type dircolors >/dev/null 2>&1; then
    eval $(dircolors --bourne-shell)
fi

# csh-compatibility
# =================
setenv() { export $1=$2 }

#-------------------------------------------------------------------------------
# Keybindings
#-------------------------------------------------------------------------------

# Somehow this ended up in my zshrc. I've seen it in a lot of other zshrcs, and
# I think that the 'key' array is a way to direcly set keybindings, but I'm not
# motivated enough to track this down.
#
#typeset -g -A key

# Bindings Mode
# =============
#
#   Though I prefer to use Vim as my editor, I prefer to use Emacs bindings for
#   my shells. I have no idea what the difference between 'bindkey -e' and
#   'setopt- o emacs' is though (or if they are synonyms).
#
bindkey -e

# Use Vim-style C-w
# =================
#
#   I like having more granularity in my C-w binding. I've remapped the default
#   C-w binding to M-w because sometimes there are string with way too many
#   special characters that I just want to quickly axe.
#
bindkey '^W'  vi-backward-kill-word
bindkey 'w' backward-kill-word

#-------------------------------------------------------------------------------
# Prompt
#-------------------------------------------------------------------------------

# Substitute variables in the $PS1 var (e.g. $HOME would get expanded)
setopt PROMPT_SUBST

source "$DOTFILES_DIR/zsh/lib/git.zsh"
source "$DOTFILES_DIR/zsh/lib/prompt.zsh"

export PROMPT='%B[%b %F{green}%n@%M%f %F{magenta}%~%f %B]%b${__GIT_BRANCH_FORMAT}${__VENV_FORMAT} %B(%b%(0?.%F{green}^_^%f.%F{red}x_X%f)%B)%b
%B%!%b %F{green}>>%f '

function prompt() {
    __GIT_BRANCH_FORMAT=""
    if is_git_repo; then
        local GIT_BRANCH_NAME=$(git_current_branch)
        export __GIT_BRANCH_FORMAT=" %B(%b%F{magenta}git:${GIT_BRANCH_NAME:-<null>}%f%B)%b"
    fi

    __VENV_FORMAT=""
    if [ -n "$VIRTUAL_ENV" ]; then
        local VENV_NAME=${VIRTUAL_ENV#$WORKON_HOME/}
        export __VENV_FORMAT=" %B(%b%F{magenta}venv:${VENV_NAME}%f%B)%b"
    fi
}

if [[ -z "${precmd_functions[(R)prompt]}" ]]; then
    precmd_functions+='prompt'
fi

#-------------------------------------------------------------------------------
# Windows
#-------------------------------------------------------------------------------

# XTerm Title Functions
# =====================
#
#   This system allows for use of ZShell's special string expansion vars within
#   an XTerm title. The value of $XTERM_TITLE will be run through 'print -P'
#   (thereby expanding the %-vars) after every command.

function set_term_title()
{
    case "$1" in
        default)
            export XTERM_TITLE="/dev/%l - %n@%m"
            ;;
        *)
            export XTERM_TITLE="$@"
            ;;
    esac
}

function display_term_title()
{
    local retval=$?
    local title_start=$'\e]0;'
    local title_end=$'\a'

    # A $TERM value of 'linux' is *usually* reserved for Linux VTs which don't
    # have any titles to set.
    if [ "$TERM" = "linux" ]; then
        return $retval
    fi

    if [ -n "$XTERM_TITLE" ]; then
        print -Pn "%{${title_start}${XTERM_TITLE}${title_end}%}"
    fi

    return $retval
}

# Make this refresh after every command
if [[ -z "${precmd_functions[(R)display_term_title]}" ]]; then
    precmd_functions+='display_term_title'
fi

# Clear Screen
# ============
#
#   When clearing the screen, just push the contents into the scrollback
#   buffer, rather then completely eliminate them. Terminal emulators like
#   xfce-terminal and gnome-terminal do this themselves, but xterm and urxvt
#   don't.
#
function clear-screen()
{
    zle -I

    if $(echo ${PROMPT:-$PS1} | wc -l) -eq 2; then
        repeat $((LINES-1)) echo
    else
        repeat $((LINES-2)) echo
    fi

    'clear'
}

zle -N clear-screen
alias clear="clear-screen"

#-------------------------------------------------------------------------------
# External Files
#-------------------------------------------------------------------------------

# Load shell.zsh files
# ====================
for zshrc_file in $DOTFILES_DIR/**/shell.zsh; do
    source "$zshrc_file"
done

# Load local zshrc settings
# =========================
LOCAL_ZSHRC="$HOME/.zshrc.local"
if [ -f "$LOCAL_ZSHRC" ]; then
    source "$LOCAL_ZSHRC"
fi

#-------------------------------------------------------------------------------
# Inspiration
#-------------------------------------------------------------------------------
#
# [1] https://github.com/davedash/zsh.d/blob/2f56ab6cc13fe957a86aa5f23312b635d79ffeda/zshrc
# [2] https://github.com/holman/dotfiles/blob/8bb17ea816dc10fd9fbc48f710dd5a2b270f90fe/zsh/zshrc.symlink
#
# vim: set syntax=zsh et sts=4 ts=4 sw=4 tw=100:
